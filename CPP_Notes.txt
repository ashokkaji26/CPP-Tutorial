

-----------------------------------------------------------------------------------------------------------------------------------------------

1.What is Text ??


 In the context of computers and programming, "text" generally refers to a sequence of characters that can be read and understood by humans.
 These characters can include letters, numbers, symbols, and spaces. Text is a fundamental data type used to represent and store information in a human-readable format.

Here's a breakdown of what "text" implies:

1. Sequence of Characters: Text is essentially an ordered collection of characters.

2. Human-Readable: The primary purpose of text is to convey information that humans can easily understand.

3. Encoding: Text is usually encoded using character encoding standards like ASCII, UTF-8, or UTF-16, which assign numerical values to each character.

4. Data Type: In programming, text is often represented using the "string" data type. A string is a sequence of characters enclosed in quotation marks (e.g., "Hello, world!").

Examples of Text:

1. "This is a sample text."
2. "12345" (even though it contains numbers, it's still text if treated as a string)
3. "Hello, how are you?"
4. "~!@#$%^&*"

In essence, "text" is the form of data that represents human language and symbols in a way that computers can store and process, and humans can read and understand.

-----------------------------------------------------------------------------------------------------------------------------------------------

2. How computers processes texts??


Yes, that's essentially correct. When a computer processes text, it internally represents each character as a numerical value according to a specific character encoding standard, such as ASCII or UTF-8.

Here's a more detailed explanation:

1. Character Encoding: Character encoding is a system that maps characters to numerical values (code points).
 ASCII is one of the earliest and simplest character encodings, but it only supports a limited set of characters (mainly English letters, numbers, and symbols).
  UTF-8 is a more modern and widely used encoding that supports a much broader range of characters, including those from different languages.

2. Representation: When a computer stores or processes text, it doesn't store the characters directly. 
Instead, it stores the numerical code points that correspond to those characters according to the chosen encoding.
 For example, if the computer is using ASCII encoding, the character 'A' would be stored as the number 65.

3. Rendering: When the computer needs to display text on the screen or print it on paper,
 it retrieves the numerical code points and uses the character encoding to look up the corresponding characters.
  It then uses a font to render the characters visually.



-----------------------------------------------------------------------------------------------------------------------------------------------

3. How computer processes text "I love you, 143 ?" ? 


Okay, let's break down how a computer would process the text "I love you, 143 ?" using the ASCII encoding system. Remember that ASCII assigns a unique number to each character.

Here's a character-by-character breakdown:

Character	ASCII Value
I	73
space 32
l	108
o	111
v	118
e	101
space 32
y	121
o	111
u	117
,	44
space 32
1	49
4	52
3	51
space 32
?	63


Process:

1. Input: The computer receives the text "I love you, 143 ?".

2. Encoding: The computer iterates through each character in the text. For each character, it looks up its corresponding ASCII value.

3. Representation: The text is then represented internally as a sequence of these ASCII values: 73, 32, 108, 111, 118, 101, 32, 121, 111, 117, 44, 32, 49, 52, 51, 32, 63 

4. Storage/Processing: These numerical values are stored in the computer's memory. The computer can then perform various operations on this data, such as displaying it on the screen, transmitting it over a network, or analyzing it.

5. Output (Display): When the computer needs to display the text, it retrieves the sequence of ASCII values. For each value, it looks up the corresponding character in the ASCII table and renders that character on the screen using a font.

So, the text "I love you, 143 ?" is internally represented as a sequence of numbers, each representing a character according to the ASCII standard.


-----------------------------------------------------------------------------------------------------------------------------------------------

4.  numbers as text V/S numbers as numerical values. 


--> Great question! It's important to distinguish between how computers handle numbers as text versus numbers as numerical values.

** Numbers as Text (Characters):

--> As we've discussed, when numbers are treated as text (i.e., part of a string), each digit is encoded as a separate character using a character encoding like ASCII.
For example, the string "123" would be stored as the ASCII values for '1', '2', and '3' (49, 50, and 51, respectively). 
In this case, the computer doesn't interpret "123" as the numerical value one hundred and twenty-three; it simply sees a sequence of three characters.

** Numbers as Numerical Values:

--> When you want the computer to perform mathematical operations or treat something as a numerical quantity, you use numerical data types like int, float, or double. In this case, the number is stored in a completely different format, using binary representation.

Here's a simplified overview of how it works for integers:

a. Binary Representation: Computers use the binary number system (base-2), which consists of only two digits: 0 and 1. Every number can be represented as a combination of 0s and 1s.

b. Storage: An integer variable (e.g., int x = 123;) is allocated a certain number of bits in memory (e.g., 32 bits). The numerical value is then converted into its binary equivalent and stored in those bits.

For example, the decimal number 123 is equivalent to the binary number 01111011. This binary representation would be stored in the allocated memory.

c. Processing: When the computer performs arithmetic operations (addition, subtraction, multiplication, etc.) on these numerical values, it operates directly on the binary representations using the rules of binary arithmetic.
Floating-Point Numbers:

--> Floating-point numbers (like float and double) are stored using a more complex format based on scientific notation. They consist of three parts:

a. Sign: Indicates whether the number is positive or negative.

b. Mantissa (Significand): Represents the significant digits of the number.

c. Exponent: Indicates the power of 2 by which the mantissa should be multiplied.

--> This representation allows computers to store a wide range of numbers, including very large and very small values, but with limited precision.

In Summary:

--> Textual Numbers (Strings): Each digit is encoded as a character using ASCII or a similar encoding. The computer treats them as symbols, not numerical values.
Numerical Values (int, float, double): Numbers are converted into binary format and stored in memory according to the data type. The computer can then perform mathematical operations directly on these binary representations.
The key difference is that textual numbers are for representing human-readable characters, while numerical values are for performing calculations and mathematical operations.




-----------------------------------------------------------------------------------------------------------------------------------------------

5. Operators:- 

  1. Compound Assignment Operators:- 
                                  Compound Assignment Operators are just a shorthand way of performing operations on a variable and assigning the result back to the variable.

x -= 5        (Subtracts 5 from x and assigns the result back to x)
x *= 3        (Multiplies x by 3 and assigns the result back to x)
x /= 3        (Divides x by 3 and assigns the result back to x)
x %= 3        (Finds the remainder when x is divided by 3 and assigns the result back to x)

-----------------------------------------------------------------------------------------------------------------------------------------------

6. Why use brackets around condition?

--> it is important to enclose the condition in brackets else C++ will throw an error.

-->  The following code will throw an error:-

#include <iostream>
using namespace std;

int main() {
    int height1 = 15;
    int height2 = 13;
    cout<<height1 != height2;
}

--> This is because the << operator has higher precedence than the != operator. So, the compiler will try to evaluate cout << height1 first, and then compare the result with height2 which is not what we want.

--> The corrected code is:-

#include <iostream>
using namespace std;

int main() {
    int height1 = 15;
    int height2 = 13;
    cout<<(height1 != height2);
}
-----------------------------------------------------------------------------------------------------------------------------------------------

7. Operator precedence:- 

        Postfix operators: ++, --
        Parentheses: ()
        Unary operators: +, -, !, ~, ++, --, (type)
        Multiplicative operators: *, /, %
        Additive operators: +, -
        Relational operators: <, >, <=, >=
        Equality operators: ==, !=
        Logical AND operator: &&
        Logical OR operator: ||
        Assignment operators: =, +=, -= 


-----------------------------------------------------------------------------------------------------------------------------------------------

8. String data type:- A string variable contains a collection of characters surrounded by double quotes.

  --> Concatenation:- The '+' sign can be used between strings to add them together to make a new string.
                      This is called concatenation.

  --> C++ uses the + sign for both addition and concatenation.

        a. Numbers are added.
        b. Strings are concatenated.
        c. We cannot mix the two.

  *** String functions:- 
            a. append()
            b. length()
            c. substr(starting index, no. of characters``) is a string function which is used to extract a substring from a given string.

-----------------------------------------------------------------------------------------------------------------------------------------------

9. conditional statements:- many times a program need to take different actions based on some conditions. 

    --> If statement :- We use if statement to check for a condition.
    --> If the condition is true we execute the code inside if block.
    --> If the condition is not ture then we execute the code inside else block.

    --> int age = 18;
        if(age >= 18){
          cout<< "You can vote!";
        }else{
          cout<< "You can't vote!";
        }


  **** If-Else can handle multiple conditions using "else-if".

--> if (condition1) {
       // Code to execute if condition1 is true
      } else if (condition2) {
        // Code to execute if condition1 is false AND condition2 is true
      } else if (condition3) {
        // Code to execute if condition1 and condition2 are false AND condition3 is true
      } else {
       // Code to execute if ALL conditions are false
      }

--> The 'else if' keyword means "if the previous conditions were not true, then try this condition".

--> The 'else' keyword includes anything which isn't included in the previous conditions.`

  --> C++ relies on curly brackets ('{' in the beginning and '}' at the end) to know what part of code is inside the if part of the code and what is not. Whatever is inside curly brackets is considered as one block of code.

  --> When writing an if or else if you don't mention a block of code using curly brackets it executes only the first statement of the if or else section.
-----------------------------------------------------------------------------------------------------------------------------------------------


10. how to use switch statements instead of multiple if-else statements??

  --> In many situations we need to perforn different actions based on a specific value.
  --> switch allows us to evaluate a single variable or expression and then execute the matching block of code.
  --> Each option is represented by a case label followed by the code for that case. 
  --> After executing the code for a matching case, we use the break keyword to exit the switch block.
  --> Without the break statement the program would fall through and execute the code for the next cases even if they don't match.
  --> The default case ensures the program handles unexpected input gracefully.
  --> switch statements provide a clean and organized way to handle multiple values of a single variable. 

  Q. when to use a switch statement instead of an if-else chain?
     --> Use a switch statement when:
        1. You have a single variable you want to compare to multiple constant values.
           The switch statement provides a cleaner and more readable way to handle multiple comparisons against the same variable.
        2. All the conditions depend on the same variable. If you're checking different conditions based on different variables,
           if-else is generally more appropriate.
  
  --> char operator = '+';
      switch ( variable or expression ){
        case '-': 
          cout << "Subtraction" <<endl;
          break;
        case '+':
          cout << "Addition" <<endl;
          break;
        case '*':
          cout << "Product" <<endl;
          break;
        case '/':
          cout<< "division" <<endl;
          break;
        default:
          cout << "Unknown Operator" <<endl;
      }


  Q. Can switch handle complex conditions?

    --> No, switch statements are not designed to handle complex conditions. They are specifically for checking a single variable against a series of constant values.

        In C++, the case labels in a switch statement must be constant expressions (e.g., literal values, enum constants, or constexpr variables). 
        You cannot use variables, ranges, or complex boolean expressions (like x > 5 && y < 10) directly in the case labels.

        If you need to evaluate complex conditions, an if-else if-else chain is the more appropriate choice.

Q. Can we use strings in switch statement ?

  --> No, you cannot use strings in a switch statement in C++. The switch statement only works with integral or enumeration types. 
      If you need to compare strings, you should use if-else statements instead.
-----------------------------------------------------------------------------------------------------------------------------------------------

11.  Debugging :- Finding and finxing errors in code.

Q. What is a bug ?
  --> A bug is an error that causes our program to generate an unexpected output that is different from our expected output or no output. 

    a. CE - Compilation error / Syntax error
    RE - Run-time error
    WA - Wrong answer / Logical error
    TLE - Time limit exceeded


-----------------------------------------------------------------------------------------------------------------------------------------------

12. Array :- 1. Array is a variable, & it is used to store multiple values in a single variable.
             2. An array is a data structure that allow us to store multiple values in a single variable, making it efficient to manage
                large collection of data.

  --> To declare an array:-
                            1. define the variable data type.
                            2. Specify the name of array followed by square brackets.
                            3. In square brackets, specify the no. of elements it should store.

  Q. Can array size be changed later ?
    --> No, No, the size of an array in C++ is fixed at the time of its declaration. Once you define an array with a specific size, 
        you cannot change its size later during the execution of the program. If you need a data structure that can dynamically grow or shrink, you should use std::vector instead of an array.

  
  ** important things to keep in mind about array:- 
      1. Arrays have a fixed size.
      2. If we need an array of a different size, we have to declare a new one.
      3. Arrays can only hold elements of the same data type.

  ** Accessing elements of an Array:- 
    --> Arrays use indexes, which are the positions of each element in the array.
    --> In c++, index starts at 0.


  Q. what does contiguous block of memory means?
    --> When you declare an array, the compiler finds a contiguous block of memory large enough to hold all the elements of the array. 
        So, if you declare an array of 5 integers, the compiler finds 5 consecutive memory locations (each large enough to hold an integer) and assigns them to your array.

        This contiguity is crucial for efficient array access because it allows the compiler to quickly calculate the address of any element by simply adding an offset to the starting address of the array, 
        as we discussed earlier. If the memory wasn't contiguous, the compiler would need to use a more complex lookup mechanism to find each element, which would slow things down.

  *** Q. Why does indexing start from 0?
        --> The reason indexing starts from 0 in C++ (and many other programming languages) is rooted in how memory addresses are calculated.

        --> Imagine an array as a contiguous block of memory. The array's name actually represents the memory address of the very first element in the array.

        --> When you access an element using arr[i], what the compiler does is:

          1. Take the starting address of the array (arr).
          2. Add "i * the size of each element" to that address. This gives you the memory address of the element you want.
          3. Go to that memory address and retrieve the value.
          4. So, arr[0] is really saying "give me the value at the starting address arr + 0 * (size of an element)", which is the first element. 
            arr[1] means "give me the value at the starting address arr + 1 * (size of an element)", which is the second element, and so on.

      ---> If indexing started at 1, the calculation would be slightly more complex (and potentially less efficient). 
           Starting at 0 makes the address arithmetic cleaner and more direct.

      ** sizeof() operator returns the size of a variable or data type in bytes.
      --> sizeof(arr);    it will give size of arr in bytes.
      --> sizeof(arr) / sizeof(arr[0]);    it will give the no. of elements in array.

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------
V
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------
V
-----------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------
V
-----------------------------------------------------------------------------------------------------------------------------------------------